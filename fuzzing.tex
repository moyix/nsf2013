Fuzz testing or fuzzing has been widely used in software vulnerability
discovery. The basic idea behind fuzzing is to generate a large number
of malformed inputs by either mutating normal inputs or directly
constructing them according to predefined generation rules, and then use
the malformed inputs to test target software. Despite the simple
concept, fuzzing has proven very effective in uncovering previously
unknown vulnerabilities in complex software. However, existing fuzzing
technologies are hardly applied to undocumented and encrypted protocols,
because the generated inputs hardly pass the integrity validations or
become meaningless after being decrypted and get dropped.
 
For example, many instant messengers (IM) encrypt all the network
traffic for privacy protection. In this case, upon receiving a message,
such an IM client would verify the integrity of the message, decrypt the
payload of the message, and further handle the decrypted data.  In
comparison with the code responsible for integrity verification and
message decryption, the code responsible for handling decrypted data is
usually more vulnerable. Unfortunately, without knowing the IM protocol,
network-fuzzing tools cannot construct a meaningful message that can
reach the most vulnerable region.
 
We propose to develop a smart fuzzing platform based on the
\dynamicsys system and the module identification analysis, with a goal
to cope with encrypted network protocols and improve the effectiveness
of fuzzing.  Our intuition is that, in order to support the
bidirectional communication, the programs (such as IM clients) capable
of decrypting messages usually own the encryption capability at the same
time.  By using dynamic data flow tracking and the module identification
analysis, we expect to identify the modules in a program that are
responsible for message encryption and decryption. As a result, rather
than constructing a malformed network packet from the scratch, we
propose to leverage the program themselves to build syntactically
correct but semantically incorrect data and then use the data to test
the programs.  
 
Take the IM clients as a concrete example.  After two IM clients
initialize the communication, we can introduce data mutation to the
input buffer of the encryption function at runtime at one side and then
send the encrypted message to the other side. In this case, the
encrypted message would be completely accepted by the other side and
reach the more vulnerable region.  Furthermore, during the process of
how the IM client handles a correctly decrypted message, we can apply
the dynamic data flow tracking technique to identify the input bytes
that flow into security sensitive operations, meaning they are more
likely to trigger vulnerabilities.  Then we use the knowledge to guide
the date mutation.

